
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Motor Control &#8212; RAPcores  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Interfaces" href="interfaces.html" />
    <link rel="prev" title="Developer Docs" href="dev.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="motor-control">
<h1>Motor Control<a class="headerlink" href="#motor-control" title="Permalink to this headline">¶</a></h1>
<p>This section describes the principles of motor control at a low level.</p>
<div class="section" id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Integrated Driver - A IC taking step/direction signals with onboard logic for commutation and microstepping</p></li>
<li><p>Commutation - The process of controlling an electrical bridge for</p></li>
<li><p>Full Bridge - A center-tapped transistor circuit allowing for either high or low (ground) voltage</p></li>
<li><p>H-Bridge - Two full bridges allowing for bidirectional current flow</p></li>
</ul>
</div>
<div class="section" id="electrical-commutation">
<h2>Electrical Commutation<a class="headerlink" href="#electrical-commutation" title="Permalink to this headline">¶</a></h2>
<p>Electrical commutation is the process of timing and controlling electrical current in the
windings of a motor. In years past you might use a brushed DC or induction motor, plug it
into you power supply or wall mains outlet and that would be it. The reason the hookup
for brushed DC is simple is due to electrical contacts called commutators. With induction
motors your mains AC voltage will generate a rotating potential in the motor making it spin,
which is also a form of commutation.</p>
<p>However, modern brushless motors require much more logic and control to perform their best.
First, since brushless motors (e.g. Steppers, BLDC) do not have electro-mechanical commutation
(hence the name “brush-less”), we need to digitally switch the motor coils on and off.
This is accomplished with arrays of transistors called “bridges” that allow for bidirectional
current flow. By controlling these bridges we can generate alternative voltages that make
the motor spin.</p>
<p>In contrast to integrated drivers e.g. that take PWM for BLDC, or step/direction for steppers,
the approach in RAPcores is to provide higher level APIs tailored for the application or
action. Some examples:</p>
<ul class="simple">
<li><p>“S”-curve stepping algorithms</p></li>
<li><p>Sensorless homing</p></li>
<li><p>Torque control</p></li>
</ul>
</div>
<div class="section" id="commutation-tables">
<h2>Commutation Tables<a class="headerlink" href="#commutation-tables" title="Permalink to this headline">¶</a></h2>
<div class="section" id="bipolar-stepper">
<h3>Bipolar Stepper<a class="headerlink" href="#bipolar-stepper" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>+</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-even"><td><p>-</p></td>
<td><p>+</p></td>
</tr>
<tr class="row-odd"><td><p>+</p></td>
<td><p>+</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="three-phase-bldc-induction">
<h3>Three Phase (BLDC, Induction)<a class="headerlink" href="#three-phase-bldc-induction" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>+</p></td>
<td><p>-</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>+</p></td>
<td><p></p></td>
<td><p>-</p></td>
</tr>
<tr class="row-even"><td><p></p></td>
<td><p>+</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p>+</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>-</p></td>
<td><p></p></td>
<td><p>+</p></td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td><p>-</p></td>
<td><p>+</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="five-phase-stepper">
<h3>Five Phase Stepper<a class="headerlink" href="#five-phase-stepper" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
<th class="head"><p>C</p></th>
<th class="head"><p>D</p></th>
<th class="head"><p>E</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>+</p></td>
<td><p></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>+</p></td>
<td><p>+</p></td>
<td><p></p></td>
<td><p>-</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p></p></td>
<td><p>+</p></td>
<td><p></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td><p>+</p></td>
<td><p>+</p></td>
<td><p></p></td>
<td><p>-</p></td>
</tr>
<tr class="row-even"><td><p>-</p></td>
<td><p></p></td>
<td><p>+</p></td>
<td><p></p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p></p></td>
<td><p>+</p></td>
<td><p>+</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>-</p></td>
<td><p>-</p></td>
<td><p></p></td>
<td><p>+</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td><p>-</p></td>
<td><p></p></td>
<td><p>+</p></td>
<td><p>+</p></td>
</tr>
<tr class="row-even"><td><p></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p></p></td>
<td><p>+</p></td>
</tr>
<tr class="row-odd"><td><p>+</p></td>
<td><p></p></td>
<td><p>-</p></td>
<td><p></p></td>
<td><p>+</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
<div class="section" id="bridge-control">
<h2>Bridge Control<a class="headerlink" href="#bridge-control" title="Permalink to this headline">¶</a></h2>
<p>Decay Modes</p>
</div>
<div class="section" id="space-vector-modulation">
<h2>Space Vector Modulation<a class="headerlink" href="#space-vector-modulation" title="Permalink to this headline">¶</a></h2>
<p>The key to smooth and efficient motor control is current regulation.
Through current regulation in a motor, one can accomplish a few valuable things:</p>
<ul class="simple">
<li><p>Microstepping (subdividing the commutation table)</p></li>
<li><p>Current regulation (limiting power output for efficiency)</p></li>
</ul>
<p>With closed loop current regulation, e.g. through a current sense resistor, additional
capabilities are also achieved:</p>
<ul class="simple">
<li><p>Fault detection</p></li>
<li><p>Phase shift and skip detection</p></li>
</ul>
<div class="section" id="vector-concepts">
<h3>Vector Concepts<a class="headerlink" href="#vector-concepts" title="Permalink to this headline">¶</a></h3>
<p>Here we will present the mathematical ideas of how to model the target current in a bipolar stepper
motor as a vector. This is known as <a class="reference external" href="https://en.wikipedia.org/wiki/Space_vector_modulation">Space Vector Modulation</a>.
To start we must understand some basic concepts from vector algebra and trigonometry.</p>
<p>Recall that sine and cosine are derived from the components of a vector rotating around the origin:</p>
<img alt="https://upload.wikimedia.org/wikipedia/commons/b/bd/Sine_and_cosine_animation.gif" src="https://upload.wikimedia.org/wikipedia/commons/b/bd/Sine_and_cosine_animation.gif" />
<p>And recall the identity where:</p>
<div class="math notranslate nohighlight">
\[cos(\theta)^2+sin(\theta)^2=1\]</div>
<p>Or alternatively:</p>
<div class="math notranslate nohighlight">
\[A \cdot cos(\theta)^2+A \cdot sin(\theta)^2=A\]</div>
<p>The above equation is essential in our understanding of constructing the vector. Recall the phase table for the bipolar stepper:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>A</p></th>
<th class="head"><p>B</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>+</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p>-</p></td>
</tr>
<tr class="row-even"><td><p>-</p></td>
<td><p>+</p></td>
</tr>
<tr class="row-odd"><td><p>+</p></td>
<td><p>+</p></td>
</tr>
</tbody>
</table>
<p>If we visualize each phase as a 2D plot we can see these commutation steps form the corners of a square as shown below:</p>
<img alt="_images/bipolar-svm.svg" src="_images/bipolar-svm.svg" /><p>Microstepping is possible in this space (a square), however it yields undesirable effects since the total current in the motor
varies due to a change of vector length as shown in the red arrow above. This can yield resonance and torque ripples. The objective
is to create smooth motion as we traverse between the phases. Therefore we need to move our vector along a circle, such as the arrows in blue above. The trade-off is
that we do not achieve the peak torque attainable in the corners of the square, but instead the motion is smooth and controllable.</p>
</div>
<div class="section" id="pwm-concepts">
<h3>PWM Concepts<a class="headerlink" href="#pwm-concepts" title="Permalink to this headline">¶</a></h3>
<p>Below is a simple PWM module in verilog:</p>
<div class="highlight-verilog notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="cm">/*</span>
<span class="cm">  Simple PWM module</span>
<span class="cm">  */</span>
  <span class="k">module</span> <span class="n">pwm</span> <span class="p">#(</span>
      <span class="k">parameter</span> <span class="n">bits</span> <span class="o">=</span> <span class="mh">8</span>
  <span class="p">)</span> <span class="p">(</span>
      <span class="k">input</span>  <span class="n">clk</span><span class="p">,</span>
      <span class="k">input</span>  <span class="n">resetn</span><span class="p">,</span>
      <span class="k">input</span>  <span class="p">[</span><span class="n">bits</span><span class="o">-</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">val</span><span class="p">,</span>
      <span class="k">output</span> <span class="n">pwm</span>
  <span class="p">);</span>

    <span class="kt">reg</span> <span class="p">[</span><span class="n">bits</span><span class="o">-</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">accum</span><span class="p">;</span>
    <span class="k">assign</span> <span class="n">pwm</span> <span class="o">=</span> <span class="p">(</span><span class="n">accum</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">);</span>

    <span class="k">always</span> <span class="p">@(</span><span class="k">posedge</span> <span class="n">clk</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">resetn</span><span class="p">)</span>
      <span class="n">accum</span> <span class="o">&lt;=</span> <span class="mh">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">resetn</span><span class="p">)</span>
      <span class="n">accum</span> <span class="o">&lt;=</span> <span class="n">accum</span> <span class="o">+</span> <span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span>

  <span class="k">endmodule</span>
</pre></div>
</td></tr></table></div>
<p>We can see that the PWM output frequency is a function of the base clock frequency (<cite>clk</cite>) and the number of bits used for the accumulator. E.g.:</p>
<div class="math notranslate nohighlight">
\[F_{PMW} = \frac{F_{clk}}{2^{bits}}\]</div>
<p>For quiet operation and fast updates we want the PWM frequency to be superaudible, so a value greater than 30khz. Assume we use a PLL to achieve
a higher operational frequency for <cite>PWM</cite> module at 150mhz. The bit resolution of the PWM can be calculated thus:</p>
<div class="math notranslate nohighlight">
\[bits = \log_2({F_{PMW}/F_{clk}})\]</div>
<p>In our example of a 30khz output with a 150mhz accumulator clock we get ~12.3 bit resolution. For simplicity we will use 12 bits going forward.</p>
<p>Now the challenge is how to compute the value to the PWM such that we bring both the current and the microstep/phase angle into a single value.
In the next section we will see this is a relatively straight forward process that falls out of the vector model.</p>
</div>
<div class="section" id="applied-space-vector-modulation">
<h3>Applied Space Vector Modulation<a class="headerlink" href="#applied-space-vector-modulation" title="Permalink to this headline">¶</a></h3>
<p>Recall that a vector (<span class="math notranslate nohighlight">\(\vec{A}\)</span>) may be element-wise scaled by a given factor such that the length (<span class="math notranslate nohighlight">\(\left\lVert\vec{A}\right\rVert\)</span>) is scaled by the same factor.
Our vector is formed from a given angle (or microstep position) <span class="math notranslate nohighlight">\(\theta\)</span> as: <span class="math notranslate nohighlight">\((cos(\theta), sin(\theta))\)</span>. Then scaling the current is simply multiplication of this vector
by a factor <cite>C</cite>: <span class="math notranslate nohighlight">\((C \cdot cos(\theta), C \cdot sin(\theta))\)</span>. Then using the above identify we known that the length of this vector is:</p>
<div class="math notranslate nohighlight">
\[\left\lVert(C \cdot cos(\theta), C \cdot sin(\theta))\right\rVert = C\]</div>
<p>Then the matter of partitioning the 12 bit space of the PWM become quite simple. For example we may use 8 bits for the trigonometric functions (implemented as lookup tables in practice), and 4 bits for current.
Which gives sufficient precision for 64 microsteps and 16 discrete current values.</p>
<p>So now we can do space vector modulation. But where do we put it? The answer is as a voltage reference or gate PWM input. For example we may use this output to
create a reference for a 1-bit ADC by adding a RC filter to the output in a <a class="reference external" href="https://en.wikipedia.org/wiki/Chopper_(electronics)">chopper drive</a>.
Or for a dead-reckoned approach this PWM can be used to quickly turn the gate drivers on and off. An example of this can be found in the RAPcores Dual H Bridge module.</p>
</div>
<div class="section" id="svm-in-three-phase">
<h3>SVM in Three Phase<a class="headerlink" href="#svm-in-three-phase" title="Permalink to this headline">¶</a></h3>
<p>For the mathematically inclined, you may notice that the bipolar stepper is nice as the phases form an orthonormal basis in 2D space. In three phase this is not the case.
We have yet to implement three phase in RAPcores, but in the interim <a class="reference external" href="https://en.wikipedia.org/wiki/Space_vector_modulation">the wikipedia page</a> has some
information on handling this case.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">RAPcores</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="releases.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="spi_spec.html">SPI Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Board Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html">Developer Docs</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Motor Control</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#electrical-commutation">Electrical Commutation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#commutation-tables">Commutation Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bridge-control">Bridge Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="#space-vector-modulation">Space Vector Modulation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="interfaces.html">Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="asic.html">RAPcores on ASIC</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="dev.html" title="previous chapter">Developer Docs</a></li>
      <li>Next: <a href="interfaces.html" title="next chapter">Interfaces</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019-2021, RAPcore developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/motor_control.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>